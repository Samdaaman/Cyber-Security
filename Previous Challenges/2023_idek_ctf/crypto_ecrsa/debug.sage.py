

# This file was *autogenerated* from the file debug.sage
from sage.all_cmdline import *   # import sage library

_sage_const_3 = Integer(3); _sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_512 = Integer(512); _sage_const_511 = Integer(511); _sage_const_0 = Integer(0)
from sage.all import *
from icecream import ic


def crack(d: int, M3, T3):
    e = _sage_const_3 
    lam = (e * d - _sage_const_1 ) // _sage_const_2 
    ic(lam)
    m, ym = M3[:_sage_const_2 ]
    t = ZZ(int.from_bytes(b"ECRSA offers added security by elliptic entropy.", 'big'))
    yt = _sage_const_2 
    # t, yt = T3[:2]
    a, b = matrix([[m, _sage_const_1 ], [t, _sage_const_1 ]]).solve_right(vector([ym**_sage_const_2  - m**_sage_const_3 , yt**_sage_const_2  - t**_sage_const_3 ]))
    ic(a, b)


def chall():
    p, q = [random_prime(_sage_const_2 **_sage_const_512 , lbound = _sage_const_2 **_sage_const_511 ) for _ in range(_sage_const_2 )]
    e = _sage_const_3 

    while gcd(p - _sage_const_1 , e) != _sage_const_1 : p = next_prime(p)
    while gcd(q - _sage_const_1 , e) != _sage_const_1 : q = next_prime(q)

    n = p*q
    d = inverse_mod(e, (p-_sage_const_1 )*(q-_sage_const_1 ))

    # d stands for debug. You don't even know n, so I don't risk anything.
    # print('d =', d)
    ic(d)
    ic(p)
    ic(q)
    ic((p-_sage_const_1 )*(q-_sage_const_1 ))

    m = ZZ(int.from_bytes(b"It is UNBREAKABLE, I tell you!! I'll even bet a flag on it, here it is: idek{REDACTED}", 'big'))
    t = ZZ(int.from_bytes(b"ECRSA offers added security by elliptic entropy.", 'big'))
    ym = randint(_sage_const_1 , n)
    yt = _sage_const_2 

    # I like it when my points lie on my curve.
    a, b = matrix([[m, _sage_const_1 ], [t, _sage_const_1 ]]).solve_right(vector([ym**_sage_const_2  - m**_sage_const_3 , yt**_sage_const_2  - t**_sage_const_3 ]))
    ic(a,b)
    E = EllipticCurve(Zmod(n), [a, b])
    M = E(m, ym)
    T = E(t, yt)

    E.base_field = E.base_ring # fix multiplication over rings (might not work depending on sage version!)
    # print('Encrypted flag:', M*e)
    # print('Encrypted test:', T*e)

    M3, T3 = M*e, T*e
    M3 = [int(x) for x in M3]
    T3 = [int(x) for x in T3]

    ic(a * m + b - ym**_sage_const_2  + m**_sage_const_3 )
    ic((a * M3[_sage_const_0 ] + b - M3[_sage_const_1 ]**_sage_const_2  + M3[_sage_const_0 ]**_sage_const_3 ))
    ic((a * M3[_sage_const_0 ] + b - M3[_sage_const_1 ]**_sage_const_2  + M3[_sage_const_0 ]**_sage_const_3 ) % n)
    ic((a * T3[_sage_const_0 ] + b - T3[_sage_const_1 ]**_sage_const_2  + T3[_sage_const_0 ]**_sage_const_3 ))
    ic((a * T3[_sage_const_0 ] + b - T3[_sage_const_1 ]**_sage_const_2  + T3[_sage_const_0 ]**_sage_const_3 ) % n)

    return d, M3, T3


def main():
    crack(*chall())


if __name__ == '__main__':
    main()

