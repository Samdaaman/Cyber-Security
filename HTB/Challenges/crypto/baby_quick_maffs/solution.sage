from Crypto.Util.number import bytes_to_long, long_to_bytes
from random import randint
from icecream import ic
from sage.all_cmdline import *   # import sage library

N = 6083782486455360611313889289556658208725888944237734041722591252756006664878102248734673207367745303402874595854966731263105387801996693270011840173939423
r = 1081087287982224274239399953615475281184099226198643053396569433856757255106426461817760194704250226883807897800355728788149068771546876055268915238961343
ciphers = [
    5408283916250636369066846815501131861319520431106165986129813106223074286810632222888292034380612581416458756909119954039579666773680866532576166358987272,
    5408283916250636369066846815501131861319520431106165986129813106223074286810632222888292034380612581416458756909119954039579666773680866532576166358987272,
    5598555010250184271123226314796180406367795504188162611960100902143581636125416986623404842897202277277978566659455918773104687212096435095590205751904580
]

N_bytes = long_to_bytes(N)

ic(len(long_to_bytes(r)))
ic(len(N_bytes))
ic(len(ciphers))

test = [len(long_to_bytes(part)) for part in ciphers]

ic(test)

two_m1_r = (ciphers[-1] - r**2 - ciphers[0]) % N
two_m1_r_plus_N = two_m1_r
while two_m1_r_plus_N % 2 != 0:
    two_m1_r_plus_N += N
        
m1_r = int(two_m1_r_plus_N / 2) % N
assert (2 * m1_r) % N == two_m1_r

inv_r = inverse_mod(r, N)
m1 = (inv_r * m1_r) % N

assert (m1 * r) % N == m1_r
assert (m1**2 + 2*m1*r + r**2) % N == ciphers[-1]

m = m1 * (len(ciphers) - 1) + r 

message = long_to_bytes(m)

ic(message)


