from operator import xor
from icecream import ic
from Crypto.Util.number import *
from itertools import product
from sage.all import *
from string import printable

q = 82349764091980216703243528787846721157571379253101971061732427939554681522787
p = 22597614376179368541927291014351181151227386315855982530475290304066480549601872481125000412312232411854471891135859606462198144416258790805203892259557432117585853522644532244043882866950543772453962473369978828348563267281282352402870551728874298860312184560283971631533453430210347478794479982659822354364676170461394200151617927348650724770337556315374296708920869883704844016422867256502854967833552352244354161923370938186895496059235837548125257119775236437293842236838420824347387394024112360489719718482356279060719080630335848636921250967340335457343005624222097640480295331833551512059471129216303573167509
g = 1522212929726315022276463307120954560926577974082882818811797965963142559037271005677110576098054722157527674127902562772533441779935566082403254092732974888203331702770403906546118095393659134079664766399608052006354212408035095060235607110586791971501473747663375215625574865706205289870455822949113508277054039439561937834562865074493156250996591912564352116714825726533396169890605271470775008065174813981767038809048518345994705536020788635479039463106099323099699225053825245500316037480436011003338091199884975066597695902083102085310246580054607257558459623691521498166469718547232285924180800892984387501802
y = 10301551349126329107088362265646928131049491442403482867496980836175873288506342576259707854365987702240527285572213439531723683002024146579359208402373918640506155640001430423630072829735081526301031527635977510509965942632354962864260004282149309957641462890526767244115715946314304320419688533957853639652278917522214541525010449214567907170562229712395613781822381944931215562795920884762599015541122869232934183665333423423899053585371134224417264749221110182731383922695086302701203378645475314119934887765168566160180674997559835947912322992312116118206408320274722250233256553213251576546136974127152356743543
q = 82349764091980216703243528787846721157571379253101971061732427939554681522787
f = (p - 1) // q
assert q * f == p - 1

ic(len(long_to_bytes(q-1)))
ct = bytes.fromhex('caaa08c4332e5701a9105ab701cc830b9ddbe18f6612c999f82a344bdc597819fba00f81772e4001bc584cff06d287089d8085a3123bdca5e7706612d7641f66a2b6228a67336c60975719ef04e1b55edad4e6850126ee92bc25692bd15e274db3b214973f224001af5f46bb40d2930cd69bae')
ic(len(ct))

key_len = 32
# key = bytes([c ^ ct[i] for i, c in enumerate(pt_start)]).ljust(key_len, b'\x00')
# ic(key)
# ic(len(ct))
# ct += b'\x00' * ((key_len - len(ct)) % key_len)

# pt = bytearray(b'_' * len(ct))

# for i in range(len(ct)):
#     if i % key_len < len(pt_start):
#         pt[i] = ct[i] ^ key[i % key_len]

# ic(pt)


# key_options = [list(range(256)) for _ in range(key_len)]

# for i in range(len(pt_start)):
#     key_options[i] = [key[i]]



ct_mod_keylen = [[] for _ in range(key_len)]
for i, k in enumerate(ct):
    ct_mod_keylen[i % key_len].append(k)


key = [set() for _ in range(key_len)]
for i in range(key_len):
    for k in range(256):
        xored = [xor(ct_char, k) for ct_char in ct_mod_keylen[i]]
        if all(c < 128 and chr(c) in printable for c in xored):
            key[i].add(k)

pt_start = b'HTB{'
for i in range(len(pt_start)):
    key[i] = {xor(pt_start[i], ct[i])}

key[(len(ct) - 1) % key_len] = {ord('}') ^ ct[i]}

prod = 1
for k in key:
    prod *= len(k)
ic(prod)
ic([len(k) for k in key])

# f_factors_dict = {}
# temp = f
# while True:
#     fac = trial_division(temp, 10^9)
#     if fac < temp:
#         if fac not in f_factors_dict:
#             f_factors_dict[fac] = 0
#         f_factors_dict[fac] += 1
#         temp = temp // fac
#         ic(temp, f_factors_dict)
#     else:
#         break
# f_factors = [p^k for p, k in f_factors_dict.items()]

# f_factors = [4, 3, 17, 2083, 290115289]
# ic(f_factors)

# residuals = []
# moduli = []

# f_ord = IntegerModRing(f).order()
# ic(f_ord)

# for fac in f_factors:
#     F = GF(q)
#     Fg = F(g)
#     Fh = F(y)
#     ic(fac)
#     gi = Fg ^ ((p-1) // fac)
#     hi = Fh ^ ((p-1) // fac)
#     xi = discrete_log(hi, gi, ord=q)
#     ic(xi)
#     residuals.append(xi)
#     moduli.append(fac)

# ic(residuals)
# ic(moduli)
# x = crt(residuals, moduli)
# ic(x)